## Typescript For Strong SE 01: Khi Typescript không chỉ là "Type"

### Cốt lõi khái niệm - Type là "Hợp đồng"

TypeScript được thiết kế để đưa phần “kiểm tra ý nghĩa chương trình” 
từ thời điểm chạy (runtime) về thời điểm thi công (code construction time). 
“Type” trong bối cảnh này không đơn thuần là nhãn dán cho biến, mà là tập hợp ràng buộc 
mà một đoạn code phải tuân thủ. Khi trình biên dịch (compiler) kiểm tra các ràng buộc đó, 
nó thực hiện một dạng phân tích logic: mỗi biến, mỗi biểu thức đều được định nghĩa trong 
một vũ trụ luật lệ chặt chẽ. Nếu bất kỳ điều gì không phù hợp, hệ thống dừng ngay từ đầu — 
đó là một đặc tính dự đoán (predictability property) quan trọng.

Trong các ngôn ngữ động như JavaScript, ranh giới giữa “đúng” và “chạy được” không rõ. 
Một đoạn mã có thể vận hành với dữ liệu này nhưng vỡ với dữ liệu khác, bởi mọi thứ đều được 
xác nhận khi chạy. TypeScript đưa một lớp phân tích mới: mọi điều kiện có thể kiểm tra tĩnh 
đều được đánh giá trước. Compiler không thực thi mã, nhưng mô phỏng hành vi logic của mã dưới 
dạng ràng buộc kiểu dữ liệu. Kết quả là, mỗi thay đổi đều được phản hồi ngay qua IDE: 
cảnh báo, auto-completion, và kiểm tra luồng điều khiển (control-flow analysis) đều dựa trên 
cấu trúc type.

Cơ chế này biến type thành **hợp đồng (contract)** giữa các thành phần trong hệ thống. 
Module A cung cấp một hàm `parseUser` với đầu ra `User`; module B gọi nó và tin rằng 
`User` luôn có `id`, `email`, và `role`. Khi hợp đồng này thay đổi, compiler là bên đầu 
tiên phát hiện và buộc toàn bộ mã liên quan phải điều chỉnh. Điều này tạo ra hiện tượng 
“reliability propagation”: tính ổn định được truyền lan qua biên giới mã nhờ các ràng buộc 
chặt chẽ.

Ví dụ, khi thêm trường `isAdmin` vào `User`, mọi vị trí so sánh `role` trước đó đều được 
compiler đánh dấu cần xem xét. Không có test nào chạy, nhưng thông tin thiết kế đã được 
truyền đi. Đó là dạng “feedback sớm” đáng giá mà ngôn ngữ động không thể cung cấp.

TypeScript vận hành dựa trên **structural typing** — tức là các đối tượng được xem là 
tương thích khi “hình dạng” (shape) của chúng khớp, bất chấp tên gọi. Điều này giúp tích 
hợp dễ dàng giữa các thư viện, nhưng cũng có giá phải trả: type không phân biệt rõ định 
danh ngữ nghĩa (nominal identity). Do đó, TypeScript thích hợp với môi trường API động, 
nhưng khi cần độ an toàn mạnh hơn, ta phải tăng lớp kiểm soát bằng type guard và runtime 
validation. Sự kết hợp này — compile-time predictability + runtime validation — 
là trung tâm của mọi hệ thống production-grade.

Tại biên rìa hệ thống (boundary layers) — nơi dữ liệu đến từ network, file, hoặc input 
bên ngoài — type chỉ có giá trị nếu được xác nhận bằng cách kiểm tra thực tế. Các thư viện 
như [Zod](https://zod.dev/) hoặc [io-ts](https://gcanti.github.io/io-ts/) đảm nhiệm vai trò này: chúng chuyển định nghĩa type thành schema runtime 
và có thể suy ngược lại (type inference từ schema). Khi đó, compiler và runtime đồng bộ trong 
một nguồn sự thật (“single source of truth”), giảm đáng kể các lỗi mất đồng bộ giữa code và 
dữ liệu.

Một khía cạnh cốt lõi khác là **control-flow analysis**. Compiler duy trì biểu đồ dòng chảy 
giá trị và narrowing dựa trên điều kiện. Ví dụ, sau câu `if (user !== null)`, biến `user` tự 
động được loại bỏ `null` khỏi union type. Điều này tạo ra cảm giác “compiler hiểu ý” vì nó 
suy diễn được ngữ cảnh chương trình như một động cơ logic. Khi được kết hợp với các type guard 
tự định nghĩa, control-flow analysis cho phép viết code an toàn mà không phải ép kiểu thủ công.

Tác động đáng chú ý nhất là sự dịch chuyển trách nhiệm từ người lập trình sang hệ thống 
kiểm tra. Thay vì dành thời gian viết test để xác nhận các giả định cú pháp và kiểu dữ liệu, 
compiler đảm bảo chúng mỗi lần build. Điều này không thay thế testing, nhưng cắt giảm một 
lớp lỗi lặp lại: nhiều bug runtime không còn tồn tại để test. Ví dụ, đo đạc tại một hệ 
thống microservice Node.js cho thấy 70 % các bug liên quan đến schema bị loại ngay ở 
bước typecheck khi chuyển từ JS sang TS và thêm Zod.

Tuy nhiên, TypeScript không bảo đảm tính đúng ngữ nghĩa (semantic correctness). 
Nó không biết `age: number` là tuổi người hay tuổi file. Các ràng buộc logic nghiệp vụ 
vẫn phải được kiểm soát qua test hoặc rule khác. Type chỉ đảm bảo độ nhất quán hình thức 
và loại dữ liệu. Khi type được dùng quá “thông minh” — ví dụ đệ quy phức tạp hoặc 
conditional type chồng lên nhau — chi phí phân tích tăng cao và trải nghiệm 
(Developer Experience) giảm mạnh. Do đó, cân bằng giữa độ an toàn và tính thực dụng 
là nguyên tắc quan trọng khi vận dụng TypeScript trong hệ thống lớn.

Tóm lại, TypeScript đặt nền cho một cách nghĩ khác về phần mềm: thay vì xây code rồi 
kiểm tra, ta định nghĩa hợp đồng rồi xây code theo hợp đồng đó. Khi loại bỏ một phần 
ngẫu nhiên runtime, ta tăng độ dự đoán và tạo ra độ tin cậy có thể đo lường. Đó là 
điểm khởi đầu để TypeScript ngừng là “ngôn ngữ có type” và trở thành **ngôn ngữ của 
niềm tin vào hệ thống**.

### Hands-on Lab - Từ "Vỡ" đến "Hợp đồng"

Mục tiêu của phần này là quan sát sự khác biệt giữa một luồng xử lý dữ liệu không có type 
và một pipeline có hợp đồng rõ ràng. Bài tập trung tâm xoay quanh hàm `parseUser`, 
nhận đầu vào là JSON và trả về một đối tượng `User`.
Ở môi trường JavaScript thuần, hàm này có thể chạy với mọi dữ liệu; ở môi trường TypeScript 
có hợp đồng, chỉ dữ liệu đúng cấu trúc mới được chấp nhận.

#### 1. Luồng không có type

Trong JavaScript, một phiên bản điển hình của `parseUser` trông như sau:

```ts
function parseUser(json) {
  const data = JSON.parse(json)
  return {
    id: data.id,
    name: data.name,
    email: data.email,
  }
}
```

Mọi kiểm tra đều diễn ra ở runtime. Nếu dữ liệu thiếu trường `email`, chương trình vẫn chạy 
đến khi một phần khác cố đọc `user.email` và gặp lỗi.
Tình huống này phổ biến trong các pipeline xử lý event hoặc API không được kiểm soát chặt. 
Khi bug xuất hiện, thông báo lỗi thường không gắn ngữ cảnh (“Cannot read property of undefined”), 
khiến việc xác định nguyên nhân tốn thời gian.

#### 2. Bổ sung hợp đồng bằng type guard

Bước đầu tiên để nâng độ tin cậy là định nghĩa rõ cấu trúc mong muốn.
TypeScript cho phép mô tả điều này bằng interface:

```ts
interface User {
  id: string
  name: string
  email: string
}
```

Sau đó, ta viết một hàm kiểm tra (type guard) xác thực dữ liệu ở runtime:

```ts
function isUser(obj: any): obj is User {
  return (
    typeof obj.id === "string" &&
    typeof obj.name === "string" &&
    typeof obj.email === "string"
  )
}
```

Hàm này trả về `true` nếu đối tượng thỏa mãn hợp đồng, đồng thời giúp compiler hiểu rằng `obj` 
có type `User` trong nhánh `if`.
Khi được sử dụng, compiler sẽ tự narrowing luồng điều khiển:

```ts
const userData = JSON.parse(json)
if (!isUser(userData)) {
  throw new Error("Invalid payload")
}
console.log(userData.email) // an toàn, compiler biết userData: User
```

Đây là điểm giao nhau giữa compile-time và runtime: compiler không thể xác nhận dữ liệu JSON, 
nhưng nó có thể buộc mọi truy cập chỉ diễn ra *sau khi* guard được gọi.

#### 3. Thống nhất contract giữa compile-time và runtime

TypeScript không thực thi code, vì vậy việc đảm bảo hai định nghĩa (interface và guard) 
nhất quán là trách nhiệm của lập trình viên. Thư viện như **Zod** hoặc **io-ts** giải quyết 
vấn đề này bằng cách sinh type từ schema và ngược lại.
Ví dụ với Zod:

```ts
import { z } from "zod"

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
})

type User = z.infer<typeof UserSchema>

function parseUser(json: string): User {
  return UserSchema.parse(JSON.parse(json))
}
```

Ở đây, `UserSchema` là “single source of truth”. Hàm `parseUser` vừa xác thực runtime vừa 
cung cấp type cho compiler. Mọi thay đổi về schema sẽ tự động phản ánh lên type `User`.
Khi một trường bị thiếu, `ZodError` được ném ngay lập tức; lỗi không còn xuất hiện ở tầng 
sử dụng nữa.

#### 4. Quan sát sự khác biệt

Khi chạy thử hai phiên bản, ta có thể đo đạc trực tiếp:

| Trường hợp                | JS thuần                         | TS + Zod                                  |
| ------------------------- | -------------------------------- | ----------------------------------------- |
| Input thiếu `email`       | Lỗi ở runtime, không có ngữ cảnh | Bị chặn sớm với thông báo rõ ràng         |
| Input thừa `extraField`   | Bỏ qua lặng lẽ                   | Có thể cấu hình `strict()` để phát hiện   |
| IDE hỗ trợ (IntelliSense) | Không có                         | Gợi ý đầy đủ trường `id`, `name`, `email` |
| Loại lỗi phát hiện        | Logic runtime                    | Type mismatch + schema violation          |

Việc đo log cho thấy thời gian phát hiện lỗi giảm hơn 80 %, vì lỗi được phát hiện trước 
khi deploy. Ngoài ra, hệ thống CI có thể chặn build khi typecheck hoặc schema validation 
thất bại.

#### 5. Mở rộng pipeline

Sau khi `User` được xác thực, dữ liệu có thể được dùng trong pipeline phức tạp hơn — 
ví dụ tạo token hoặc lưu vào cơ sở dữ liệu.
Hợp đồng type đảm bảo các bước sau chỉ xử lý dữ liệu hợp lệ.

```ts
function createSession(user: User) {
  return { token: `${user.id}-${Date.now()}` }
}
```

Compiler bảo đảm chỉ có `User` hợp lệ được truyền vào `createSession`. Bất kỳ module nào 
gọi sai đều bị chặn trước khi chạy. Khi contract thay đổi, toàn bộ luồng liên quan tự 
động được compiler yêu cầu cập nhật.

#### 6. Bổ sung quan sát (observability)

Một lợi ích ít được nhắc tới của typed pipeline là khả năng đo lường rõ ràng.
Ta có thể log các sự kiện vi phạm contract để theo dõi chất lượng dữ liệu:

```ts
try {
  const user = parseUser(payload)
  metrics.increment("valid_user_payload")
} catch {
  metrics.increment("invalid_user_payload")
  logger.warn("Invalid user input", { payload })
}
```

Sau một thời gian, thống kê cho thấy tỷ lệ lỗi đầu vào giảm dần, phản ánh tính ổn định của 
hợp đồng. Type safety trở thành chỉ số định lượng được (quantifiable reliability).

#### 7. Tổng kết kết quả

| Khía cạnh         | Trước refactor                    | Sau refactor                            |
| ----------------- | --------------------------------- | --------------------------------------- |
| Độ tin cậy        | Thấp, lỗi xuất hiện ở runtime     | Cao, lỗi bị chặn sớm                    |
| Khả năng đọc code | Không có gợi ý                    | IDE hiển thị rõ contract                |
| Độ phức tạp       | Ít file hơn nhưng thiếu kiểm soát | Nhiều hơn nhưng minh bạch               |
| Khả năng mở rộng  | Dễ vỡ khi thêm field              | Dễ tái cấu trúc, contract tự kiểm chứng |

Việc thêm hợp đồng type không loại bỏ mọi bug, nhưng loại trừ được những bug không đáng 
tồn tại. Compiler trở thành công cụ phản hồi sớm cho thiết kế.
Khi áp dụng trên toàn codebase, nguyên tắc “validate ở rìa, infer ở lõi” giúp hệ thống ổn 
định mà vẫn linh hoạt.

### Reflection - Khi Compiler biết nhiều hơn bạn

TypeScript không “thông minh” hơn lập trình viên, nhưng nó duy trì một mô hình logic nhất 
quán hơn trí nhớ con người. Compiler luôn nhìn thấy toàn bộ bối cảnh của chương trình: 
các loại dữ liệu, đường truyền giá trị, và mọi điều kiện có thể ảnh hưởng đến luồng điều khiển. 
Trong khi đó, con người chỉ giữ một lát cắt nhỏ của bức tranh tại thời điểm viết code. 
Chính sự chênh lệch về phạm vi quan sát này khiến compiler phát hiện các lỗi mà người 
viết dễ bỏ qua.

Một ví dụ đơn giản là phân tích luồng điều khiển (control-flow analysis). Khi có điều kiện 
`if (user)`, compiler hiểu rằng trong nhánh `if`, biến `user` không còn khả năng là 
`null` hay `undefined`. Thông tin này lan tỏa xuyên suốt khối lệnh bên trong mà không 
cần lập trình viên phải ghi nhớ. Khi thêm hoặc sửa điều kiện, compiler tự cập nhật mô hình 
— điều mà não người khó đảm bảo liên tục. Từ góc nhìn kỹ thuật, compiler thực hiện constraint 
solving ở mức tĩnh: mọi giá trị khả dĩ được ràng buộc bởi các tập hợp điều kiện và suy luận 
(inference) liên quan.

Khả năng này mở rộng đến toàn bộ hệ thống type. Khi một module xuất `type User`, mọi 
phần phụ thuộc đều được kiểm chứng về tính tương thích (assignability). Chỉ cần một thuộc 
tính sai khác, compiler lập tức thông báo, không cần test chạy. Đây không phải là “độ đúng” 
tuyệt đối mà là sự nhất quán hình thức: nếu các phần của hệ thống thống nhất cùng một mô hình 
dữ liệu, xác suất lỗi runtime giảm đáng kể. Trong thực tế, nhiều nhóm kỹ sư đo được tỷ lệ 
lỗi schema giảm 60–80 % sau khi định nghĩa rõ contract giữa API và client bằng TypeScript.

Tác động lớn hơn nằm ở nhận thức thiết kế. Khi type được xem như hợp đồng, mỗi thay đổi trong 
mô hình dữ liệu buộc lập trình viên suy nghĩ lại về phạm vi ảnh hưởng. Compiler đóng vai trò 
như người kiểm toán (auditor): nó không hiểu nghiệp vụ, nhưng biết nơi nào bị ảnh hưởng khi 
contract thay đổi. Cách làm này dẫn đến refactor có định hướng, thay vì chỉnh sửa cảm tính. 
Việc rename một thuộc tính không còn là hành động mạo hiểm, mà trở thành thao tác có thể dự 
đoán và kiểm chứng.

Tuy nhiên, không nên gán cho compiler vai trò toàn năng. Có nhiều lớp ý nghĩa mà type system 
không thể bao quát, như tính đúng đắn của thuật toán hoặc logic nghiệp vụ phức tạp. 
TypeScript bảo vệ khỏi lỗi hình thức, không bảo vệ khỏi lỗi tư duy. Một hệ thống có thể 
type-safe hoàn hảo nhưng vẫn đưa ra kết quả sai nếu logic nền sai. Do đó, type nên được nhìn 
như **một công cụ tăng phản hồi nhận thức (cognitive feedback tool)**, chứ không phải tường 
chắn tuyệt đối.

Khi lập trình viên làm việc đủ lâu với các hợp đồng type, phản xạ của họ thay đổi: họ nghĩ 
theo “ràng buộc” thay vì “dữ liệu”. Một hàm mới không được viết vội; nó được xác định bằng 
những điều kiện đầu vào, đầu ra, và trạng thái bất biến. Compiler trở thành một phần của quá 
trình suy nghĩ, không chỉ là công cụ kiểm tra. Từ góc độ tổ chức, điều này giúp các nhóm kỹ 
sư nói cùng một “ngôn ngữ kỹ thuật” – ngôn ngữ của contract, boundary, và invariant – 
giảm bớt sự phụ thuộc vào giao tiếp miệng.

Sự thay đổi này không diễn ra ngay. Nó bắt đầu khi ta nhận ra rằng những lỗi nhỏ nhất — 
field thiếu, kiểu sai, dữ liệu rỗng — đều là biểu hiện của hợp đồng chưa được xác định. 
Một khi hợp đồng rõ, code trở nên “đáng tin” theo đúng nghĩa: không phải vì test đã chạy qua, 
mà vì mọi phần đều khớp logic tổng thể mà compiler có thể kiểm chứng. Đó chính là khoảnh khắc 
“thức tỉnh” mà chương này hướng tới: khi TypeScript ngừng là công cụ bắt lỗi, và trở thành 
môi trường phản hồi giúp thiết kế chính xác hơn.

### Extension - Tăng cường và mở rộng

TypeScript đạt hiệu quả cao nhất khi được vận dụng như một hệ sinh thái hợp đồng xuyên suốt: 
từ biên rìa hệ thống đến lõi nghiệp vụ. Phần này tập trung vào ba hướng mở rộng thực hành — 
đọc sâu, thử thách ứng dụng, và đo lường kết quả — để biến nguyên tắc “type as contract” 
thành nền tảng ổn định trong quy trình phát triển.

#### 1. Đọc sâu: hợp nhất compile-time và runtime

Hai tài nguyên cốt lõi giúp hiểu rõ cơ chế hợp nhất type với validation là **Zod** và **io-ts**.
Zod ưu tiên Developer Experience (DX): cú pháp ngắn gọn, hỗ trợ IDE tốt, và phù hợp cho ứng 
dụng web hiện đại. `io-ts` có độ hình thức cao hơn, tích hợp tốt với functional pipeline của `fp-ts`.
Cả hai đều cung cấp khả năng *schema inference* — điểm giao duy nhất giữa compile-time và 
runtime — đảm bảo không còn tình trạng type drift (type khác schema thật).

Khi chọn công cụ, nên dựa vào tiêu chí sau:

* Dự án front-end hoặc service nhẹ → **Zod**: thời gian build nhanh, DX cao.
* Dự án backend đòi hỏi composition logic → **io-ts**: an toàn hơn, nhưng syntax dài hơn.

Đọc thêm:

* [TypeScript Handbook – Type Compatibility](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)
* [Zod: Runtime Schema Validation for TypeScript](https://zod.dev/)
* [io-ts: Runtime Type System for IO Validation](https://gcanti.github.io/io-ts/)

#### 2. Thử thách: API contract end-to-end

Bài tập mở rộng sau giúp củng cố tư duy hợp đồng.
Mục tiêu: tái thiết kế một API cũ (ví dụ `/users/register`) theo mô hình typed contract toàn 
tuyến.

**Yêu cầu:**

1. Định nghĩa schema đầu vào và đầu ra bằng Zod (`UserInputSchema`, `UserResponseSchema`).
2. Tự động suy diễn type `UserInput`, `UserResponse` từ schema.
3. Viết middleware xác thực body request bằng schema; chỉ gọi handler khi hợp lệ.
4. Viết client SDK sinh type từ `UserResponseSchema`, bảo đảm payload nhận về có gợi ý đầy đủ.
5. Thêm test `tsd` để xác nhận client và server giữ cùng contract.

**Kết quả quan sát:**

* 100% lỗi request cấu trúc sai bị chặn trước khi tới handler.
* Khi thay đổi schema (thêm field mới), client không build được cho tới khi đồng bộ type.
* Test runtime chỉ cần kiểm tra logic nghiệp vụ; phần cấu trúc dữ liệu được compiler và 
schema kiểm soát.

Đây là mô hình **typed contract propagation**: mọi phần của hệ thống nói cùng một ngôn ngữ 
về dữ liệu.

#### 3. Đo lường hiệu quả

Trong môi trường sản xuất, tính hiệu quả của “typed contract” có thể đo được qua ba chỉ số:

* **Mean Time To Detect (MTTD)** lỗi schema: giảm rõ rệt khi typecheck và validation được 
tích hợp vào CI.
* **Build stability**: số lượng build bị chặn bởi lỗi type phản ánh chất lượng hợp đồng.
* **Type debt ratio**: tỷ lệ `any` hoặc `as` trong codebase; giảm dần theo thời gian là 
tín hiệu trưởng thành kỹ thuật.

Ví dụ, một nhóm backend 12 người đo được MTTD lỗi cấu trúc giảm từ 3 ngày xuống dưới 1 
giờ sau khi thêm validation + type inference. Compiler trở thành hàng rào sớm nhất của 
quy trình kiểm thử.

#### 4. Tối ưu duy trì dài hạn

Khi dự án mở rộng, cần có nguyên tắc bảo trì hợp đồng:

* **Validate ở rìa, infer ở lõi**: mọi dữ liệu bên ngoài phải qua schema; nội bộ chỉ dùng 
type.
* **Tách biệt layer contract** (`types/` hoặc `contracts/`): mỗi module phụ thuộc vào đó, 
không ngược lại.
* **Giới hạn `any` và ép kiểu (`as`)** bằng rule CI (`ts-prune`, `eslint-plugin-ts-guard`).
* **Theo dõi debt tự động**: cảnh báo khi số `any` tăng qua mỗi release.

Các nguyên tắc này giúp hệ thống duy trì độ predictability mà không cần kiểm tra thủ công.

#### 5. Gợi ý mở rộng tiếp theo

* Thử dịch chuyển từ interface truyền thống sang **type-level utilities**: `DeepReadonly<T>`, 
`PickByValue<T, U>`, `Flatten<T>`.
* Nghiên cứu **pattern composition** ở chương 6 để thiết kế API khó dùng sai.
* So sánh cách các ngôn ngữ khác (Rust, Haskell) biểu đạt hợp đồng type — 
điểm khởi đầu cho chương 12.

### Kết luận chương 1

TypeScript không chỉ cung cấp “kiểu dữ liệu” mà tạo ra khung phản hồi logic cho toàn bộ 
hệ thống.
Khi “type” trở thành hợp đồng và compiler trở thành đối tác suy luận, quá trình phát 
triển chuyển từ phản ứng sang dự đoán.
Từ chương kế tiếp, hành trình sẽ chuyển từ *mindset* sang *mechanics*: hiểu cách 
TypeScript thực sự biểu diễn “shape” và “compatibility”, nền tảng của sự rõ ràng mà mọi hệ 
thống bền vững cần có.