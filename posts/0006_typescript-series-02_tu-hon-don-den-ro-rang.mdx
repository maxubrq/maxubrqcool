## Typescript For Strong SE 02: Từ "Hỗn độn" đến "Rõ ràng" - Sự thay đổi tư duy từ JS sang TS

### Cốt lõi khái niệm

JavaScript là ngôn ngữ động, nơi type chỉ tồn tại ở runtime và được gán ngầm theo giá trị. 
Cách hoạt động này giúp tốc độ thử nghiệm cao, nhưng cũng khiến ranh giới giữa các module 
trở nên mờ. Một function có thể nhận bất kỳ dạng input nào, và lỗi chỉ xuất hiện khi đường 
chạy thực tế chạm vào nhánh đó. TypeScript được thiết kế như một lớp bảo vệ ở compile-time, 
bổ sung mô hình type tĩnh (static type system) nhưng không làm mất đi tính linh hoạt vốn có. 
Nó cho phép định nghĩa rõ contract giữa các phần trong hệ thống, và nhờ vậy, mỗi thay đổi 
trong code đều được kiểm tra trước khi chạy.

Khác với các ngôn ngữ có nominal type system (như Java, C#), TypeScript áp dụng **structural 
typing**: hai type được xem là tương thích nếu chúng có cùng “shape”, tức cùng tập hợp thuộc 
tính và kiểu giá trị. Cơ chế này phản ánh đặc trưng của JavaScript — nơi giá trị quan trọng 
hơn danh xưng. Khi một object có đầy đủ thuộc tính mà một interface yêu cầu, nó được coi là 
hợp lệ, bất kể tên type khác nhau. Cách tiếp cận này giúp khả năng tương tác cao giữa các 
module và thư viện, nhưng cũng làm tăng nguy cơ “accidental compatibility” — hai cấu trúc 
chỉ tình cờ trùng shape nhưng không cùng ý nghĩa nghiệp vụ.

Trong structural typing, khái niệm **assignability** giữ vai trò trung tâm. Một giá trị có 
thể gán cho biến kiểu **_T_** khi mọi thuộc tính mà **_T_** yêu cầu đều tồn tại và tương thích 
trong giá 
trị nguồn. Quy tắc này đi kèm với cơ chế **widening** và **narrowing**. Khi compiler không 
thể suy ra type cụ thể, nó “mở rộng” (widen) giá trị sang type tổng quát hơn, như từ literal 
`"a"` sang `string`. Ngược lại, trong flow kiểm tra điều kiện, compiler có thể “thu hẹp” 
(narrow) type, ví dụ khi gặp `typeof x === "number"`. Nhờ vậy, TypeScript có thể phân tích 
control flow để dự đoán type tại từng điểm trong chương trình — một khả năng hiếm có ở ngôn 
ngữ dạng “optional static typing”.

Một khác biệt quan trọng khác nằm ở **inference** — cơ chế suy luận type. Compiler có thể 
xác định type của biến dựa trên giá trị khởi tạo hoặc biểu thức return. Điều này giảm bớt 
nhu cầu khai báo dài dòng, nhưng dễ dẫn đến tình huống “inference mờ”: khi contract không 
được ghi rõ, người khác khó hiểu được ý định thiết kế. Quy tắc thực hành phổ biến là *annotate 
boundary, infer interior*: khai báo rõ input và output của function hoặc module 
(tức là contract bên ngoài), còn bên trong để compiler tự suy luận. Nhờ đó, hệ thống vừa an 
toàn vừa linh hoạt.

Sự khác biệt giữa **interface** và **type alias** thường gây nhầm lẫn. Interface mô tả hình 
dạng của một thực thể có thể mở rộng được, trong khi type alias đại diện cho bất kỳ biểu thức 
type nào — kể cả union, intersection hoặc mapped type. Interface phù hợp để định nghĩa các API 
surface ổn định, nơi khả năng mở rộng quan trọng (ví dụ `interface Request { ... }` có thể được 
mở rộng bởi nhiều module). Type alias mạnh hơn trong các phép biến đổi type (type-level 
computation), ví dụ `type Result<T> = T | Error`. Trong các codebase lớn, thông lệ là dùng 
interface cho public API và type alias cho logic nội bộ hoặc utility types.

TypeScript cho phép “mượn” tính mở rộng của interface để tạo sự tương thích giữa các module, 
nhưng cũng khiến ranh giới contract dễ bị nới lỏng nếu không kiểm soát. Khi cần độ nghiêm ngặt 
cao hơn, có thể dùng “branding” hoặc “nominal tagging” để thêm một thuộc tính giả định, ví dụ 
`type UserId = string & { readonly __brand: 'UserId' }`. Nhờ đó, các giá trị có cùng shape 
(`string`) nhưng khác brand sẽ không còn tương thích. Đây là cách phổ biến để kiểm soát 
accidental compatibility trong production systems.

Tuy nhiên, không phải lúc nào việc gắn type cũng mang lại lợi ích. Một số phần của JavaScript 
— như dynamic object access (`obj[key]`) hoặc JSON parse từ nguồn bên ngoài — vẫn đòi hỏi 
kiểm tra runtime. TypeScript không thể đảm bảo an toàn tuyệt đối vì type bị loại bỏ sau quá 
trình compile. Để bù lại, các thư viện như **Zod** hoặc **io-ts** cung cấp cơ chế runtime 
validation đồng bộ với compile-time type, giúp bảo toàn contract cả trong và ngoài compiler. 
Mối quan hệ giữa compile-time và runtime validation là yếu tố cốt lõi để giữ tính toàn vẹn 
trong hệ thống phức tạp.

Cấu hình TypeScript quyết định mức độ nghiêm khắc của kiểm tra. Các tùy chọn như `strict`, 
`noImplicitAny`, `exactOptionalPropertyTypes`, và `noUncheckedIndexedAccess` nên được bật 
mặc định trong mọi dự án sản xuất. Chúng ép developer định nghĩa rõ ràng mỗi thuộc tính và 
tránh những vùng “unknown” mà compiler không thể phân tích. Việc bật strictness có thể tạo 
ra nhiều lỗi ban đầu, nhưng đó chính là “type debt” được bộc lộ sớm thay vì phát sinh âm thầm 
trong runtime. Một hệ thống ổn định lâu dài đòi hỏi loại bỏ debt này trước khi mở rộng quy mô.

Cuối cùng, để duy trì kỷ luật, cần thiết lập các quy tắc lint và kiểm tra tự động trong CI. 
Ví dụ, ESLint có thể được cấu hình để cấm `any`, yêu cầu `exhaustive switch`, và chặn 
`ban-ts-comment` trừ khi có lý do cụ thể. Khi kết hợp với kiểm tra type trong pipeline, 
những quy tắc này biến compiler thành một đồng đội kiểm thử không mệt mỏi, đảm bảo codebase 
phát triển mà không mất tính toàn vẹn.

### Hands-on Lab - Structural Typing trong thực tế

Phần này trình bày cách chuyển một module JavaScript không có type thành phiên bản 
TypeScript đáng tin cậy. 
Mục tiêu là quan sát cách compiler kiểm tra shape, inference, và strictness trong từng bước, 
qua đó hình thành cảm giác “code tự mô tả”.

#### Bước 1 - Khởi tạo và kiểm tra baseline

Tạo thư mục dự án và khởi tạo TypeScript:

```bash
mkdir legacy-to-ts && cd legacy-to-ts
pnpm init -y
pnpm add -D typescript eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin
npx tsc --init
```

Trong `tsconfig.json`, bật các tùy chọn nghiêm ngặt:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true
  }
}
```

Thêm một file `user.js` mô phỏng module cũ:

```js
function parseUser(json) {
  const data = JSON.parse(json);
  return { name: data.name, age: data.age };
}
```

Khi chạy `parseUser('{"name": "Ana"}')`, không có cảnh báo nào dù dữ liệu thiếu `age`. 
Ở runtime, hệ thống chỉ phát hiện lỗi khi logic phía sau đụng tới thuộc tính bị thiếu.

#### Bước 2 - Di chuyển sang TypeScript và xem compiler phản ứng

Đổi tên file thành `user.ts` và bật type checking:

```ts
export function parseUser(json: string) {
  const data = JSON.parse(json);
  return { name: data.name, age: data.age };
}

const user = parseUser('{"name":"Ana"}');
console.log(user.age.toFixed());
```

TypeScript không thể biết `data` có thuộc tính `age` hay không, nên `user.age` 
có thể là `any`. Khi bật `noImplicitAny`, compiler sẽ cảnh báo. Đây là dấu hiệu đầu 
tiên cho thấy hệ thống bắt đầu “phản hồi” — thay vì chờ lỗi ở runtime, ta thấy vấn đề 
ngay tại build.

#### Bước 3 - Thêm type rõ ràng và tránh compatibility ngẫu nhiên

Định nghĩa contract bằng `interface`:

```ts
interface User {
  name: string;
  age: number;
}

export function parseUser(json: string): User {
  const data = JSON.parse(json);
  return { name: data.name, age: data.age };
}
```

Compiler hiện đã đảm bảo rằng hàm luôn trả về giá trị phù hợp với shape của `User`. 
Tuy nhiên, nếu dữ liệu thật thiếu `age`, lỗi vẫn xảy ra ở runtime. TypeScript chỉ kiểm soát 
compile-time; để kiểm soát runtime, cần validation.

Thêm `zod` để kiểm tra runtime:

```bash
pnpm add zod
```

Và cập nhật code:

```ts
import { z } from "zod";

const UserSchema = z.object({
  name: z.string(),
  age: z.number()
});

export type User = z.infer<typeof UserSchema>;

export function parseUser(json: string): User {
  const data = JSON.parse(json);
  return UserSchema.parse(data);
}
```

Giờ đây, compiler đảm bảo rằng mọi nơi sử dụng `User` đều an toàn, và runtime validation 
đảm bảo dữ liệu thực sự khớp với contract. Hai lớp kiểm tra này — compile-time và runtime — 
cùng duy trì predictability của hệ thống.

#### Bước 4 - Minh họa structural typing và nominal branding

Tạo thêm hai type có cùng shape:

```ts
interface Customer {
  name: string;
  age: number;
}

const c: Customer = { name: "Ana", age: 27 };
const u: User = c; // OK – cùng shape
```

Vì cả `Customer` và `User` có cùng thuộc tính, TypeScript cho phép gán lẫn nhau. 
Đây là điểm mạnh nhưng cũng là rủi ro của structural typing.

Để phân biệt hai domain có cùng shape, thêm “brand”:

```ts
type UserId = string & { readonly __brand: "UserId" };
type CustomerId = string & { readonly __brand: "CustomerId" };

function loadUser(id: UserId) {}
function loadCustomer(id: CustomerId) {}

// const a: UserId = "abc"; // lỗi: cần ép kiểu
```

Branding ép compiler xem chúng là khác biệt, tránh nhầm lẫn logic trong hệ thống nhiều domain.

#### Bước 5 - Thực hành inference và annotation ranh giới

Xây dựng hàm `loadUser` minh họa “annotate boundary, infer interior”:

```ts
async function loadUser(id: UserId): Promise<User> {
  const res = await fetch(`/api/user/${id}`);
  const data = await res.json();
  return UserSchema.parse(data);
}

const name = (await loadUser("u123" as UserId)).name;
```

Input (`id`) và output (`Promise<User>`) được annotate rõ ràng, trong khi phần thân 
function để compiler tự suy luận. Việc này giúp code dễ đọc và ổn định khi refactor.

#### Bước 6 - Dựng union type và exhaustiveness check

Giả lập luồng dữ liệu có nhiều trạng thái:

```ts
type RemoteData<T> =
  | { kind: "Idle" }
  | { kind: "Loading" }
  | { kind: "Success"; data: T }
  | { kind: "Failure"; error: Error };

function render(u: RemoteData<User>) {
  switch (u.kind) {
    case "Idle":
      return "Waiting...";
    case "Loading":
      return "Loading...";
    case "Success":
      return u.data.name;
    case "Failure":
      return u.error.message;
    default:
      const _exhaustive: never = u;
      return _exhaustive;
  }
}
```

Nếu thêm biến thể mới, compiler sẽ báo lỗi vì `default` không còn “never”. 
Cơ chế này giúp đảm bảo mọi nhánh logic đều được xử lý — một dạng 
“exhaustive-by-construction”.

#### Bước 7 - Thêm kiểm soát CI và quan sát kết quả

Cấu hình ESLint để cấm `any` và ép `exhaustive switch`:

```json
{
  "rules": {
    "@typescript-eslint/no-explicit-any": "error",
    "sonarjs/no-all-duplicated-branches": "warn"
  }
}
```

Thêm bước CI:

```yaml
jobs:
  typecheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v3
      - run: pnpm install
      - run: pnpm tsc --noEmit
      - run: pnpm eslint .
```

Khi pipeline báo lỗi `any`, team được nhắc ngay. Mỗi commit có thể đo “type debt” 
bằng số lượng cảnh báo còn lại. Đây là cách duy trì hygiene dài hạn.

#### Kết quả mong đợi

Sau khi hoàn tất, developer quan sát được:

* Compiler bắt lỗi sớm, runtime crash giảm đáng kể.
* DX cải thiện: IDE hiểu rõ shape, autocomplete chính xác.
* Refactor API ít rủi ro hơn vì type contract dẫn hướng.
* CI chặn được mọi `any` hoặc assertion không rõ ràng.

Từ đây, hệ thống không chỉ “chạy được” mà còn “được compiler xác nhận đúng”.

### Reflection — Ranh giới giữa sự linh hoạt và độ tin cậy

TypeScript tạo ra một không gian trung gian giữa hai cực: 
JavaScript tự do và hệ thống tĩnh chặt chẽ như Rust hoặc Haskell. Cái giá của tự do trong 
JavaScript là sự mơ hồ: mọi giá trị đều có thể mang bất kỳ hình dạng nào, và điều đó chỉ 
được xác nhận khi chương trình chạy. TypeScript đưa vào trật tự, nhưng không cưỡng ép 
hoàn toàn. Người viết code phải quyết định mức độ nghiêm ngặt cần thiết — điều mà compiler 
không thể tự phán đoán. Sự chuyển dịch tư duy ở đây nằm ở việc xem **type như hợp đồng 
kỹ thuật (contract)** chứ không phải như cú pháp bổ sung.

Khi codebase lớn dần, khả năng compiler hiểu đúng ý định của con người trở nên quan 
trọng hơn. Một đoạn code có thể “compile xanh” nhưng vẫn sai về mặt logic. Do đó, độ tin cậy 
của hệ thống phụ thuộc vào cách contract được biểu đạt. Khi annotation rõ ràng, 
compiler trở thành cộng sự: nó không chỉ kiểm tra lỗi mà còn giúp tái cấu trúc an toàn. Khi 
annotation mờ, compiler chỉ còn là người kiểm lỗi cú pháp. Mối quan hệ này không cố định; 
nó phụ thuộc vào mức độ mà developer “mở lòng” cho compiler thấy ý định thật của mình qua 
type.

Cũng như mọi công cụ kiểm soát, type có thể bị lạm dụng. Một type “quá thông minh” — 
chứa hàng chục điều kiện, mapped type lồng nhau, hay union sâu tới mức khó đọc — 
có thể khiến developer mất định hướng. Khi đó, safety biến thành gánh nặng nhận thức 
(cognitive load). Nguyên tắc thực tế là **type phục vụ người đọc, không phục vụ compiler**. 
Một type đơn giản, dễ hiểu thường đáng tin cậy hơn một type phức tạp cố chứng minh điều 
gì đó ở compile-time. Compiler không thể thay thế được tư duy kiến trúc, chỉ có thể khuếch 
đại nó.

Một điểm quan trọng khác là **ranh giới giữa compile-time và runtime**. Nhiều kỹ sư nhầm 
rằng nếu type system mạnh, có thể loại bỏ hoàn toàn kiểm tra runtime. Thực tế, **TypeScript 
không tồn tại ở runtime**; toàn bộ type bị xóa sau khi biên dịch. Do đó, các dữ liệu đến từ 
network, file system hay input người dùng vẫn cần được xác thực. Cách đúng là để runtime 
validation củng cố contract compile-time — như cặp đôi `zod` và `z.infer`. Khi compile-time 
và runtime hợp nhất, hệ thống trở nên bền vững hơn vì mỗi lớp bảo vệ phát hiện lỗi ở giai 
đoạn sớm nhất có thể.

Trong các nhóm phát triển lớn, giá trị của type không chỉ nằm ở kỹ thuật mà còn ở tổ chức. 
Một module có type rõ ràng giúp người khác hiểu nhanh ý định của người viết mà không cần đọc 
chi tiết implementation. Một contract typed là một tài liệu sống: nó di chuyển cùng code, 
được compiler kiểm chứng mỗi khi thay đổi. Việc duy trì kỷ luật “annotate boundary” vì 
thế không chỉ là best practice — đó là nền tảng để giữ cho tri thức tập thể không bị phân 
rã khi dự án mở rộng.

Cuối cùng, cần chấp nhận giới hạn: TypeScript không thể chứng minh mọi tính đúng đắn, và 
cũng không nên cố. Có những lỗi chỉ lộ ra ở runtime, có những logic phụ thuộc trạng thái mà 
type không thể diễn đạt. Độ tin cậy vì vậy không đến từ việc ép hệ thống tuyệt đối an toàn, 
mà từ việc **giảm entropy ở nơi có thể kiểm soát**. Khi type được dùng đúng, ta không loại 
bỏ được mọi bất định, nhưng ta có thể dự đoán được phạm vi của nó — và đó chính là nền tảng 
của code đáng tin cậy.

### Extension — Mở rộng và đào sâu

Việc nắm vững structural typing không chỉ là hiểu cơ chế của compiler mà còn là học cách 
thiết kế hệ thống dựa trên contract rõ ràng. Phần mở rộng này gợi ý các hướng đọc, 
thử nghiệm và cải thiện codebase thực tế, giúp kỹ sư không dừng ở “code đúng” mà tiến 
tới “hệ thống đáng tin cậy”.

#### 1. Đọc sâu (Deep Reads)

**[TypeScript Handbook — Type Compatibility](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)**
Phần này mô tả chi tiết cơ chế structural typing, assignability và variance. Đọc 
kỹ các ví dụ về subtype và interface merging sẽ giúp hiểu vì sao hai type có thể tương 
thích dù khác tên. Nắm rõ nguyên tắc này là điều kiện tiên quyết để xây dựng API có khả 
năng mở rộng mà vẫn an toàn.

**Effective TypeScript — Item 7, 8, 20**
Những mục này bàn về inference, annotation, và cách “để compiler làm việc cùng bạn thay 
vì chống lại bạn”. Đặc biệt, mục “Prefer type inference where possible, but annotate 
boundaries” tóm gọn triết lý đã trình bày trong chương này.

**TypeScript 5.x Release Notes**
Theo dõi các cải tiến như `satisfies`, `const type parameters`, và “narrowing by equality”. 
Mỗi tính năng mới của compiler thường phản ánh xu hướng an toàn hóa ecosystem — hiểu chúng 
giúp dự đoán hướng tiến hóa của TypeScript.

**Zod Documentation**
Phần `z.infer` và `safeParse` cho thấy cách đồng bộ giữa runtime validation 
và compile-time contract. Đây là cầu nối quan trọng giữa thế giới động của dữ liệu 
và logic tĩnh của compiler.

#### 2. Thử thách kỹ thuật (Challenges)

**Challenge A — Viết `DeepReadonly<T>`**
Tạo utility type biến mọi thuộc tính lồng nhau thành `readonly`. Bài tập này giúp hiểu 
recursion và mapped types, đồng thời chuẩn bị cho Chapter 4 (type computation). Kiểm tra 
bằng `tsd` để đảm bảo type hoạt động đúng với các trường hợp sâu.

**Challenge B — Thiết kế `Brand<T, Tag>` tổng quát**
Xây dựng hàm tiện ích tạo nominal type an toàn:

```ts
type Brand<T, Tag extends string> = T & { readonly __brand: Tag };
```

Áp dụng nó vào ID của nhiều domain khác nhau (`UserId`, `OrderId`, `SessionId`) 
và đo xem bao nhiêu bug gán nhầm bị chặn ngay ở compile-time.

**Challenge C — Refactor module cũ loại bỏ mọi `as` không cần**
Chọn một module trong codebase có nhiều assertion (`as`) hoặc `any`, 
rồi refactor dần. Ghi lại số lượng lỗi compiler ban đầu và số còn lại sau mỗi bước. 
Mục tiêu không phải đạt con số 0, mà là khiến mỗi assertion còn lại đều có lý do rõ ràng, 
được ghi chú trong code review.

#### 3. Áp dụng trong hệ thống thực

**Typed API Boundaries**
Định nghĩa interface cho các endpoint REST hoặc GraphQL bằng type literal, ví dụ:

```ts
interface GetUserResponse {
  id: string;
  name: string;
  roles: string[];
}
```

Sử dụng công cụ như `openapi-typescript` hoặc `graphql-codegen` để sinh type tự động, 
đảm bảo tính đồng nhất giữa client và server. Đây là ứng dụng trực tiếp của nguyên tắc 
“annotate boundary”.

**Type Hygiene CI**
Thêm bước kiểm tra type trong pipeline:

```bash
pnpm tsc --noEmit
```

Kết hợp với ESLint rule `@typescript-eslint/no-explicit-any` để ngăn rò rỉ `any` mới. 
Qua thời gian, CI trở thành thước đo “type debt” — phản ánh sức khỏe hệ thống.

**Incremental Strictness Adoption**
Nếu dự án quá lớn để bật `strict` ngay, có thể chia thành nhiều giai đoạn:

* Giai đoạn 1: `noImplicitAny`
* Giai đoạn 2: `strictNullChecks`
* Giai đoạn 3: `exactOptionalPropertyTypes`
  Ghi lại metric compile-time errors và tốc độ build để đánh giá tiến triển.

#### 4. Kết nối sang chương tiếp theo

Những khái niệm trong chương này là tiền đề cho **Chapter 3 — Anatomy of the Type System**, nơi 
TypeScript được nhìn như một logic engine: cách compiler giải bài toán constraint và quyết 
định assignability. Nếu chương 2 trả lời “làm sao để viết code đáng tin cậy”, thì chương 3 
sẽ trả lời “vì sao compiler có thể hiểu được điều đó”.

### Tổng kết chương 2

Từ chaos của JavaScript đến clarity của TypeScript là hành trình biến ngôn ngữ lập trình 
thành ngôn ngữ của hợp đồng. Structural typing không chỉ là chi tiết kỹ thuật, mà là biểu 
hiện của một triết lý: hệ thống trở nên ổn định khi mỗi phần hiểu rõ điều nó mong đợi và 
điều nó hứa hẹn. Khi đó, compiler không còn là người canh cổng, mà là đồng đội cùng bảo vệ 
tính toàn vẹn của toàn bộ codebase.
