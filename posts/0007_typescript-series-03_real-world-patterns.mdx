Welcome to the final part of the TypeScript Fundamentals series! We've covered the basics and advanced types. Now let's bring it all together with real-world patterns and best practices you'll use every day.

## Series Recap

Let's review what we've learned:

**Part 1:** TypeScript basics, setup, fundamental types, and interfaces  
**Part 2:** Advanced types, generics, utility types, and type guards  
**Part 3 (This Post):** Real-world patterns, React integration, and best practices

## TypeScript with React

TypeScript and React are a perfect match. Here's how to use them together:

### Functional Components

```typescript
import React from 'react';

// Props interface
interface ButtonProps {
  label: string;
  onClick: () => void;
  disabled?: boolean;
  variant?: 'primary' | 'secondary';
}

// Functional component with typed props
const Button: React.FC<ButtonProps> = ({ 
  label, 
  onClick, 
  disabled = false,
  variant = 'primary'
}) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      className={`btn btn-${variant}`}
    >
      {label}
    </button>
  );
};

export default Button;
```

### useState with TypeScript

```typescript
import { useState } from 'react';

interface User {
  id: number;
  name: string;
  email: string;
}

function UserProfile() {
  // TypeScript infers the type
  const [count, setCount] = useState(0);
  
  // Explicit type annotation
  const [user, setUser] = useState<User | null>(null);
  
  // Array state
  const [items, setItems] = useState<string[]>([]);
  
  return (
    <div>
      <p>Count: {count}</p>
      {user && <p>User: {user.name}</p>}
    </div>
  );
}
```

### Custom Hooks

```typescript
import { useState, useEffect } from 'react';

interface UseFetchResult<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
}

function useFetch<T>(url: string): UseFetchResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    async function fetchData() {
      try {
        const response = await fetch(url);
        const json = await response.json();
        setData(json);
      } catch (err) {
        setError(err as Error);
      } finally {
        setLoading(false);
      }
    }

    fetchData();
  }, [url]);

  return { data, loading, error };
}

// Usage
function UserList() {
  const { data, loading, error } = useFetch<User[]>('/api/users');
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  
  return (
    <ul>
      {data?.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

## Configuration Best Practices

### tsconfig.json Essentials

```json
{
  "compilerOptions": {
    // Enable all strict type checking
    "strict": true,
    
    // Modern JavaScript features
    "target": "ES2020",
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    
    // Module resolution
    "moduleResolution": "node",
    "esModuleInterop": true,
    "resolveJsonModule": true,
    
    // Path mapping
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"]
    },
    
    // JSX support
    "jsx": "react-jsx",
    
    // Output
    "outDir": "./dist",
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    
    // Quality checks
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist"]
}
```

## Design Patterns

### Repository Pattern

```typescript
// Generic repository interface
interface Repository<T> {
  getAll(): Promise<T[]>;
  getById(id: string): Promise<T | null>;
  create(item: Omit<T, 'id'>): Promise<T>;
  update(id: string, item: Partial<T>): Promise<T>;
  delete(id: string): Promise<void>;
}

// User repository implementation
class UserRepository implements Repository<User> {
  private apiUrl = '/api/users';

  async getAll(): Promise<User[]> {
    const response = await fetch(this.apiUrl);
    return response.json();
  }

  async getById(id: string): Promise<User | null> {
    const response = await fetch(`${this.apiUrl}/${id}`);
    if (!response.ok) return null;
    return response.json();
  }

  async create(user: Omit<User, 'id'>): Promise<User> {
    const response = await fetch(this.apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(user)
    });
    return response.json();
  }

  async update(id: string, user: Partial<User>): Promise<User> {
    const response = await fetch(`${this.apiUrl}/${id}`, {
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(user)
    });
    return response.json();
  }

  async delete(id: string): Promise<void> {
    await fetch(`${this.apiUrl}/${id}`, { method: 'DELETE' });
  }
}
```

### Builder Pattern

```typescript
class QueryBuilder {
  private query: string[] = [];
  private params: Record<string, any> = {};

  select(...fields: string[]): this {
    this.query.push(`SELECT ${fields.join(', ')}`);
    return this;
  }

  from(table: string): this {
    this.query.push(`FROM ${table}`);
    return this;
  }

  where(condition: string, params?: Record<string, any>): this {
    this.query.push(`WHERE ${condition}`);
    if (params) {
      this.params = { ...this.params, ...params };
    }
    return this;
  }

  orderBy(field: string, direction: 'ASC' | 'DESC' = 'ASC'): this {
    this.query.push(`ORDER BY ${field} ${direction}`);
    return this;
  }

  build(): { query: string; params: Record<string, any> } {
    return {
      query: this.query.join(' '),
      params: this.params
    };
  }
}

// Usage
const { query, params } = new QueryBuilder()
  .select('id', 'name', 'email')
  .from('users')
  .where('age > :age', { age: 18 })
  .orderBy('name', 'ASC')
  .build();
```

## Common Patterns

### Result Type Pattern

```typescript
// Result type for error handling
type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

async function fetchUser(id: number): Promise<Result<User>> {
  try {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) {
      return {
        success: false,
        error: new Error(`HTTP ${response.status}`)
      };
    }
    const data = await response.json();
    return { success: true, data };
  } catch (error) {
    return {
      success: false,
      error: error as Error
    };
  }
}

// Usage
const result = await fetchUser(1);
if (result.success) {
  console.log(result.data.name); // Type-safe!
} else {
  console.error(result.error.message);
}
```

### Discriminated Unions

```typescript
// State machine with discriminated unions
type LoadingState = 
  | { status: 'idle' }
  | { status: 'loading' }
  | { status: 'success'; data: User[] }
  | { status: 'error'; error: string };

function renderUsers(state: LoadingState) {
  switch (state.status) {
    case 'idle':
      return <div>Click to load users</div>;
    case 'loading':
      return <div>Loading...</div>;
    case 'success':
      return <div>{state.data.length} users loaded</div>;
    case 'error':
      return <div>Error: {state.error}</div>;
  }
}
```

## Testing with TypeScript

### Jest with TypeScript

```typescript
// user.service.ts
export class UserService {
  async getUser(id: number): Promise<User> {
    const response = await fetch(`/api/users/${id}`);
    return response.json();
  }
}

// user.service.test.ts
import { UserService } from './user.service';

describe('UserService', () => {
  let service: UserService;

  beforeEach(() => {
    service = new UserService();
  });

  it('should fetch user by id', async () => {
    // Mock fetch
    global.fetch = jest.fn(() =>
      Promise.resolve({
        json: () => Promise.resolve({
          id: 1,
          name: 'John Doe',
          email: 'john@example.com'
        })
      })
    ) as jest.Mock;

    const user = await service.getUser(1);
    
    expect(user.name).toBe('John Doe');
    expect(user.email).toBe('john@example.com');
  });
});
```

## Performance Tips

### Type-Only Imports

```typescript
// Import only types (removed at compile time)
import type { User } from './types';

// Regular import (includes runtime code)
import { fetchUser } from './api';
```

### Const Assertions

```typescript
// Without const assertion
const config = {
  api: 'https://api.example.com',
  timeout: 5000
}; // Type: { api: string; timeout: number }

// With const assertion
const config = {
  api: 'https://api.example.com',
  timeout: 5000
} as const; // Type: { readonly api: "https://api.example.com"; readonly timeout: 5000 }
```

## Anti-Patterns to Avoid

### Don't Use 'any'

```typescript
// ❌ Bad
function processData(data: any) {
  return data.value;
}

// ✅ Good
function processData(data: { value: string }) {
  return data.value;
}

// ✅ Even better with generics
function processData<T extends { value: string }>(data: T) {
  return data.value;
}
```

### Don't Ignore Errors

```typescript
// ❌ Bad
try {
  // @ts-ignore
  someFunction();
} catch {}

// ✅ Good
try {
  someFunction();
} catch (error) {
  console.error('Error:', error);
  // Handle the error properly
}
```

## Final Quiz

Test your overall TypeScript knowledge:

<Quiz 
  question="What is the best way to handle potentially null values in TypeScript?"
  options={[
    "Use 'any' type",
    "Use optional chaining and nullish coalescing",
    "Disable strict null checks",
    "Always use non-null assertion (!)"
  ]}
  correctAnswer={1}
/>

<Quiz 
  question="Which pattern is best for handling async operations with multiple states?"
  options={[
    "Using boolean flags",
    "Using discriminated unions",
    "Using any type",
    "Using multiple useState calls"
  ]}
  correctAnswer={1}
/>

## Series Complete! 🎉

Congratulations on completing the TypeScript Fundamentals series!

<ProgressBar 
  steps={[
    'TypeScript Basics',
    'Advanced Types',
    'Real-world Patterns'
  ]}
  currentStep={2}
/>

## What You've Learned

Throughout this series, you've mastered:

✅ TypeScript basics and fundamental types  
✅ Advanced type features and generics  
✅ Utility types and type manipulation  
✅ Real-world patterns and best practices  
✅ React integration  
✅ Testing strategies  
✅ Performance optimization  

## Next Steps

Now that you've completed this series, consider:

1. **Build a Project** - Apply these concepts in a real application
2. **Explore the Ecosystem** - Learn TypeScript libraries and frameworks
3. **Contribute to Open Source** - Practice with real-world codebases
4. **Share Your Knowledge** - Teach others what you've learned

## Resources

- [TypeScript Official Documentation](https://www.typescriptlang.org/docs/)
- [TypeScript Playground](https://www.typescriptlang.org/play)
- [DefinitelyTyped](https://definitelytyped.org/) - Type definitions
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)

Thank you for following along with this series. Happy typing! 🚀

---

*This is Part 3 (Final) of the TypeScript Fundamentals series. You're now equipped to build professional, type-safe applications!*

