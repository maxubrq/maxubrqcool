## GitHub Actions 102 – Cấu trúc và vòng đời của một workflow

### Concept — Khi một file YAML trở thành pipeline sống

Khi tôi bắt đầu dùng GitHub Actions cho dự án thật, ấn tượng đầu tiên là: “Tất cả chỉ nằm trong một file YAML sao?”
Và rồi, tôi mất gần một tuần để hiểu chuyện gì thực sự xảy ra sau khi nhấn *push*.

Về cơ bản, một workflow trong GitHub Actions là một “pipeline khai báo” (declarative pipeline).
Nó không chạy ngay khi bạn viết, mà mô tả *cái gì cần làm*, còn *làm thế nào* — GitHub tự quyết.
Cấu trúc YAML gồm ba khối chính: `on`, `jobs`, và `steps`.

`on` là phần kích hoạt. Nó định nghĩa event nào khiến workflow chạy — ví dụ `push`, `pull_request`, hoặc `workflow_dispatch` (kích hoạt thủ công).
Mỗi event được GitHub đưa vào hàng đợi nội bộ, rồi ánh xạ đến file YAML tương ứng trong repo.

Tiếp theo là `jobs`. Mỗi job chạy trong một runner riêng biệt — tách biệt hoàn toàn.
Runner này có thể là *GitHub-hosted* (do GitHub cấp) hoặc *self-hosted* (do bạn quản lý).
Điều đó nghĩa là mỗi job giống như một container sạch, không có state từ job khác, trừ khi bạn truyền artifact hoặc output.
Điều này nghe đơn giản, nhưng trong thực tế, hiểu rõ *scope* của job và *ràng buộc* giữa chúng là thứ quyết định pipeline có chạy ổn định hay không.

Trong mỗi job, có nhiều `steps`.
Mỗi step chạy tuần tự, trong cùng một môi trường shell, có thể là `bash`, `pwsh`, hoặc `cmd` tùy runner.
Step có thể là `uses:` (gọi action có sẵn) hoặc `run:` (chạy command trực tiếp).
Và chỉ khi một step fail (exit code ≠ 0), toàn bộ job bị đánh dấu thất bại — trừ khi bạn gắn `continue-on-error: true`.

Toàn bộ hành trình thực thi diễn ra như sau:

1. **Trigger:** một event như `push` xảy ra → GitHub check repo có file YAML tương ứng.
2. **Queue:** workflow được đưa vào hàng đợi build.
3. **Runner:** GitHub chọn runner phù hợp (ubuntu-latest, windows-latest…).
4. **Checkout:** mã nguồn được clone xuống runner.
5. **Setup:** các action chuẩn bị môi trường (`setup-node`, `setup-python`, v.v.)
6. **Execute:** từng step được thực thi, log được gửi ngược về UI theo thời gian thực.
7. **Teardown:** upload artifact, cleanup môi trường, kết thúc job.
8. **Report:** tổng hợp kết quả, hiển thị badge, gửi status về commit hoặc PR.

Điều đáng chú ý là toàn bộ quá trình này diễn ra trong sandbox tạm thời — runner bị hủy sau khi xong.
Không có “cache” bền vững nếu bạn không thiết lập `actions/cache`.
Điều đó làm workflow an toàn, nhưng đôi khi rất chậm, đặc biệt với build nặng hoặc nhiều dependency.

Lúc đó tôi nhận ra: YAML chỉ là bề nổi. Phần quan trọng là hiểu cách GitHub _thực thi_ và _ghi nhớ_ từng bước.

### Build — Khi YAML trở thành pipeline thực thụ

Khi chúng tôi bắt đầu viết workflow đầu tiên cho hệ thống Node.js, mọi thứ trông đơn giản: build, test, done.
Nhưng đến lần thứ ba bị fail mà không hiểu vì sao, tôi nhận ra mình không thực sự hiểu “cấu trúc” bên trong YAML đó.

Đây là ví dụ workflow ban đầu mà nhóm dùng:

```yaml
name: CI Basic
on: [push, pull_request]

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: 20
      - name: Install deps
        run: npm ci
      - name: Run tests
        run: npm test
```

Nó hoạt động, nhưng có vài điều thú vị nếu đọc log kỹ hơn.
Ngay khi `push` xảy ra, GitHub gửi event payload (gồm branch, commit SHA, actor, v.v.) vào hàng đợi.
Runner được cấp phát, clone code, rồi thực thi từng `step`.
Nếu bạn để ý log, bạn sẽ thấy rõ thời điểm GitHub “phát hiện” workflow, thời gian *queue*, và khi runner “start job container”.
Những vài chục giây đầu đó — chính là *overhead* mà nhiều người không để ý.

Sau này, khi build thời gian dài, chúng tôi thêm cache để giữ lại dependency:

```yaml
- name: Cache node_modules
  uses: actions/cache@v4
  with:
    path: ~/.npm
    key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
```

Chỉ riêng việc này giảm thời gian chạy trung bình từ 5 phút xuống 2 phút.
Nhưng cache cũng khiến workflow khó debug hơn: đôi khi build fail do cache cũ, chứ không phải code.
Chúng tôi học được phải thêm một step log hash key, để hiểu khi nào cache được hit, khi nào miss.

Rồi đến bước **debug**.
GitHub Actions cung cấp biến `ACTIONS_STEP_DEBUG=true`.
Khi bật, log hiện chi tiết từng biến môi trường (`GITHUB_REF`, `GITHUB_SHA`, `GITHUB_WORKSPACE`).
Tôi nhớ có lần một PR test mãi không chạy.
Hóa ra workflow định nghĩa `on: push`, mà pull request không sinh event `push` — nó cần `on: pull_request`.
Chỉ nhờ đọc log và event context, mới nhận ra mình đang lẫn hai khái niệm.

Một điều tôi thấy quan trọng là **đặt tên step và job rõ ràng**.
Khi bạn chạy nhiều job song song, log dễ loạn nếu đều là “Run tests”.
Chúng tôi chuyển sang convention kiểu:
`build_node20`, `build_node18`, `lint_code`, `unit_test`, `integration_test`.
Sau này khi nhìn bảng log, chỉ cần vài giây là biết job nào fail, job nào skip do dependency.

Đến khi pipeline lớn hơn, tôi bắt đầu dùng `needs:` để ràng buộc job.
Ví dụ:

```yaml
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - run: echo "build done"

  test:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - run: echo "test after build"
```

`needs` đơn giản, nhưng nó là chìa khóa để tránh *race condition*.
Trong pipeline phức tạp, việc quên `needs` có thể khiến job chạy song song ngoài ý muốn,
và fail ngẫu nhiên vì dependency chưa hoàn tất.
Sau này tôi mới hiểu, phần “vòng đời” của workflow chính là: **ai chạy trước, ai phụ thuộc ai, và khi nào log được hợp nhất**.

### Reflect — Khi workflow bắt đầu sống và có “tính cách” riêng

Sau vài tháng vận hành, tôi nhận ra mỗi workflow có “tính khí” riêng — có cái nhanh, có cái chậm, có cái thi thoảng cáu bẳn.
Lý do không nằm ở YAML, mà ở cách ta tổ chức nó.

Một workflow tốt không chỉ chạy đúng, mà còn phải **đọc được**.
GitHub Actions UI về bản chất là trình đọc log, nên nếu bạn đặt tên kém, dùng quá nhiều step lặp,
hoặc không ghi chú, debugging sẽ tốn thời gian gấp đôi.
Tôi đã từng mất hai giờ chỉ để tìm lỗi do thiếu `shell: bash` trong step, vì log bị cuộn sâu trong hàng trăm dòng setup.

Điều tôi học được là nên **viết workflow như code sản xuất**: có convention, có format, có intent rõ ràng.
Tên job viết theo mục đích (`build`, `test`, `deploy`), step ghi cụ thể hành động (`Install deps`, `Run lint`, `Run tests`).
Khi người mới vào repo, họ có thể đọc YAML và hình dung ngay chuỗi build chạy thế nào.
Workflow càng trong sáng, debug càng nhanh.

Một kinh nghiệm nhỏ khác là **đọc log theo trình tự thời gian thực thi**, không theo cảm tính.
Nhiều người chỉ nhìn phần “Run tests” vì thấy nó fail, nhưng thực tế nguyên nhân nằm ở phần setup trước đó —
ví dụ Node chưa cài đúng version, hoặc thiếu quyền checkout submodule.
Khi tôi học cách xem log từ trên xuống, từ setup → steps → teardown,
thì tỷ lệ tìm đúng nguyên nhân trong lần đầu tăng rõ rệt.

Có lần pipeline của chúng tôi mất 40 phút chỉ để chạy lint và test.
Không phải do code nặng, mà do chạy tất cả job song song mà không chia dependency.
Sau khi tách thành `lint` → `build` → `test`, tổng thời gian còn 17 phút,
dù tổng step không đổi.
GitHub không tối ưu *tự động*, mà dựa trên cách ta khai báo vòng đời hợp lý.

Điều thú vị là càng về sau, tôi càng thấy YAML này không khác gì một chương trình nhỏ.
Nó có cấu trúc, có state tạm, có biến (`env`, `outputs`), có điều kiện (`if:`).
Chỉ khác ở chỗ: bạn không chạy nó trực tiếp, mà “yêu cầu GitHub” chạy thay.
Đó là lý do workflow cần được tổ chức cẩn thận — để bạn và GitHub hiểu nhau chính xác.

Cuối cùng, điều quan trọng nhất tôi rút ra là:

> *Workflow là ảnh phản chiếu độ trưởng thành của đội ngũ kỹ sư.*
> Một team viết YAML sạch, có log dễ đọc, có dependency rõ,
> thường cũng là team hiểu pipeline của mình chạy thế nào — và vì sao.

Từ đây, chúng ta đã có nền tảng vững: hiểu cách workflow được kích hoạt,
cách job và step chạy trong runner, và cách vòng đời kết thúc.
Bước tiếp theo, ta đi sâu hơn vào phần “xương sống” của nó —
**Jobs, Runners, và Context: cách GitHub Actions thực thi thật sự bên dưới.**
